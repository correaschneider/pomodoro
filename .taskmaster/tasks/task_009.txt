# Task ID: 9
# Title: Update checker with cached remote JSON and non-intrusive UX
# Status: pending
# Dependencies: 1, 3, 5
# Priority: medium
# Description: Implement periodic update checks against a remote JSON definition, with caching, offline-first behavior, and optional user-triggered check.
# Details:
Implementation (ADR-006):
- infrastructure/update/checker.py:
  - Config: URL from settings or constant; interval (e.g., once per day), timeout 3–5s; opt-out in settings.
  - Cache file in user data dir: {"last_checked": ts, "last_result": {...}}
  - Fetch via urllib.request or httpx/requests if allowed; parse fields {version, changelog, url, hash?}
  - Compare versions using packaging.version.Version; if newer, emit signal to UI/NotificationService
  - Expose check_now() and schedule(auto=True) using background thread or Qt timer (no UI blocking)
  - UX: Show tray/notification with changelog summary and button to open download URL; never auto-download.
Pseudo-code:
class UpdateChecker(QtCore.QObject):
    update_available = QtCore.Signal(str, str, str)  # version, changelog, url
    def schedule(self): QtCore.QTimer.singleShot(5_000, self._maybe_check)
    def _maybe_check(self):
        if cache_fresh(): return
        threading.Thread(target=self._check_worker, daemon=True).start()
    def _check_worker(self):
        try: data = json.load(urlopen(URL, timeout=4))
        except Exception: log and return
        if Version(data['version']) > Version(APP_VERSION): self.update_available.emit(...)
Deliverables: checker module, integration in GUI (menu action "Check for updates"), notification wiring.

# Test Strategy:
- Unit: version comparison logic with various SemVer cases; cache freshness handling.
- Integration: monkeypatch network to return sample JSON; assert signals emitted; simulate offline error and ensure no UI block.
- Manual: verify notification text and that clicking action opens URL via QDesktopServices.openUrl.

# Subtasks:
## 1. Cache design and freshness policy [pending]
### Dependencies: None
### Description: Design and implement a persistent cache for update checks in the user data directory with freshness checks to avoid redundant network calls.
### Details:
Implement in infrastructure/update/checker.py. Use platformdirs.user_data_dir('pomodoro_app', appauthor=None) to store a file update_check.json. Schema: {"last_checked": unix_ts_int_utc, "last_result": {"version": str, "changelog": str, "url": str, "hash": str|null}}. Provide functions: load_cache(path) -> dict|None (gracefully handle missing/corrupt files), save_cache(path, data) with atomic write (write to temp then rename), is_cache_fresh(last_checked, interval_s) -> bool. Default interval: 86400s (once/day) configurable via settings. Offline-first behavior: cache only gates frequency; do not surface stale last_result as a new update. Ensure directory creation and permissions. Log parse errors and fall back to empty cache.

## 2. Networking and JSON parsing [pending]
### Dependencies: 9.1
### Description: Fetch the remote update definition JSON with timeout, custom user-agent, and robust error handling.
### Details:
Implement fetch_update_json(url, timeout_s) using urllib.request (avoid extra deps). Build Request with headers: User-Agent: "PomodoroApp/{APP_VERSION} ({platform}; {python_ver})", Accept: application/json. Timeout: 3–5s from settings. Handle URLError, HTTPError, timeout, and SSL errors by logging and returning None. Parse response as JSON with json.loads, validate required fields: version (str), changelog (str), url (str). Optionally accept hash. Validate the download URL via urllib.parse.urlparse (scheme http/https). Do not raise; return a dict on success or None on failure.

## 3. Versioning and pre-release handling [pending]
### Dependencies: 9.2
### Description: Compare remote and local versions using packaging.version with rules for pre-releases.
### Details:
Introduce helper compare_versions(remote_ver_str, local_ver_str, allow_prerelease=False) -> bool that returns True if a newer update should be surfaced. Use packaging.version.Version for both. Rules: if remote is pre-release and allow_prerelease is False, do not notify unless local is also pre-release and remote > local. If remote is stable and greater than local (stable or pre), notify. Handle invalid version strings by logging and skipping notification. Normalize versions consistently. Expose allow_prerelease via settings (default False).

## 4. Scheduling, threading, and public API [pending]
### Dependencies: 9.1, 9.2, 9.3
### Description: Provide check_now() and schedule(auto=True) APIs with Qt timer kickoff, background worker thread, settings opt-out, and single-flight guard.
### Details:
Create class UpdateChecker(QtCore.QObject) in infrastructure/update/checker.py with signal update_available(version:str, changelog:str, url:str). Methods: schedule(auto=True) uses QtCore.QTimer.singleShot(initial_delay_ms) to call _maybe_check(); _maybe_check() loads cache and returns early if is_cache_fresh and auto=True; otherwise spawns threading.Thread(target=_check_worker, daemon=True) guarded by a threading.Lock to prevent concurrent checks. check_now() bypasses freshness and invokes _check_worker in a background thread. _check_worker(): read settings (URL, timeout, interval, opt-out). If opt-out True, return. Call fetch_update_json(); on success, update cache last_checked and last_result. If compare_versions(...) True, emit update_available(remote_version, changelog, url). Ensure no UI blocking; catch and log exceptions. Respect interval via cache freshness gate only.

## 5. UX and GUI integration [pending]
### Dependencies: 9.4
### Description: Wire the update signal to NotificationService and add a GUI action for manual checks without auto-download.
### Details:
Connect UpdateChecker.update_available to a handler that calls NotificationService.notify with title like "Update available v{version}" and message containing a short changelog summary. Provide an action/button "Download" that opens the URL via Qt.QDesktopServices.openUrl. Never auto-download. Add a menu or tray action "Check for updates" in the GUI that calls checker.check_now(). Ensure notifications are non-intrusive (use tray/notification per NotificationService fallback chain). Consider i18n of strings. Truncate overly long changelogs and include an ellipsis.

## 6. Testing: cache, networking, versioning, and integration [pending]
### Dependencies: 9.1, 9.2, 9.3, 9.4, 9.5
### Description: Implement unit and integration tests for cache freshness, version comparisons, network behaviors, and UI signaling.
### Details:
Unit tests: cache load/save with tmp_path, atomic write, and freshness boundaries; version comparison across SemVer, pre-release, build metadata, and invalid versions. Networking: monkeypatch urllib to simulate success, timeout, HTTP error, invalid JSON; verify None on failure and that User-Agent header is set. Integration (pytest-qt): instantiate UpdateChecker with a test settings object and temp cache; simulate remote JSON responses; assert that update_available signal emits only when appropriate; verify check_now() bypasses freshness; verify opt-out prevents network calls. Performance: ensure schedule() returns immediately and no UI block (thread used).

